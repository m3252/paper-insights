# Out of the Tar Pit

- [paper link](https://curtclifton.net/papers/MoseleyMarks06a.pdf)

>복잡성은 대규모 소프트웨어 시스템을 성공적으로 개발하는 데 있어 가장 큰 어려움이다. 브룩스(Brooks)를 따라 우발적(accidental) 복잡성과 본질적(essential) 복잡성을 구분하지만, 현대 시스템에 남아 있는 대부분의 복잡성이 본질적이라는 그의 전제에는 동의하지 않는다. 우리는 복잡성을 초래하는 일반적인 원인을 식별하고, 그것이 우발적인 경우 이를 제거할 수 있는 일반적인 접근 방식을 논의한다. 이를 보다 구체적으로 설명하기 위해, 함수형 프로그래밍과 코드(Codd)의 관계형 데이터 모델을 기반으로 한 잠재적인 복잡성 최소화 접근법의 개요를 제시한다.


# 소프트웨어 복잡성에 대한 고찰

## 1. 서론

1968년, "소프트웨어 위기(software crisis)"라는 개념이 처음 등장한 이후 수십 년 동안 문제는 완화되기보다 오히려 심화되었다. 대규모 소프트웨어 시스템의 개발 및 유지보수에서 가장 큰 문제는 복잡성(complexity)이며, 이러한 복잡성은 시스템을 이해하기 어렵게 만든다.

특히, 많은 시스템에서 복잡성을 야기하는 주요 요인은 **상태(state)의 처리**이다. 상태를 다루는 과정에서 발생하는 부담은 시스템을 분석하고 논리적으로 추론하는 능력을 저해한다. 여기에 코드의 양(code volume)과 시스템 내 제어 흐름(control flow) 관리까지 더해지면서 복잡성은 더욱 심화된다.

이 문제를 해결하기 위한 대표적인 방법으로 **객체 지향 프로그래밍(OOP)** 과 **함수형 프로그래밍(FP)** 이 존재한다. OOP는 상태를 관련된 동작과 결합하는 방식을 취하는 반면, FP는 상태와 부수 효과(side-effects)를 제거하는 접근 방식을 따른다. 하지만 이 두 가지 방법론 모두 전통적인 대규모 시스템에 적용할 때 다양한 문제를 야기한다.

우리는 OOP와 FP의 장점을 적절히 결합하고, **관계형 데이터베이스(relational database)의 개념**을 적용함으로써 보다 효율적인 대안을 모색할 수 있다고 본다.

---

## 2. 복잡성(Complexity)

브룩스(Brooks)는 그의 논문 *"No Silver Bullet"* 에서 소프트웨어 개발을 어렵게 만드는 네 가지 특성을 제시했다:

- **복잡성(Complexity)**
- **일관성(Conformity)**
- **변경 가능성(Changeability)**
- **비가시성(Invisibility)**

이 중에서 우리는 복잡성이 가장 중요한 요소라고 본다. 나머지는 복잡성의 한 형태이거나, 복잡성 때문에 문제가 되는 것들에 불과하다.

복잡성은 오늘날 소프트웨어가 직면한 **대부분의 문제들의 근본 원인**이다. **신뢰성 부족, 일정 지연, 보안 취약성, 성능 저하** 등은 모두 복잡성을 효과적으로 관리하지 못한 결과라고 할 수 있다. 시스템을 이해할 수 있어야 문제를 해결할 수 있는데, 복잡성은 이러한 이해를 방해한다.

복잡성의 위험성과 단순성의 중요성은 여러 학자들에 의해 강조되어 왔다.

- **다익스트라(Dijkstra)**:
  > *"우리는 우리가 만든 복잡성에 짓눌리지 않으려면, 명확하고 단순하게 유지해야 한다."*

- **코르바토(Corbato) (1990년 튜링상 수상 강연)**:
  > *"야심 찬 시스템들이 직면하는 일반적인 문제는 복잡성이다."*  
  > *"복잡성은 어려움을 더욱 증폭시키므로, 단순성과 우아함의 가치를 강조하는 것이 중요하다."*

- **배커스(Backus) (1977년 튜링상 강연)**:
  > *"우리가 프로그램을 사고하는 방식을 도울 강력한 방법론이 절실히 필요하다... 기존의 프로그래밍 언어들은 프로그램을 이해하는 방식에 불필요한 혼란을 야기한다."*

- **호어(Hoare) (1980년 튜링상 강연)**:
  > *"신뢰성을 확보하기 위한 대가는 극도의 단순성을 추구하는 것이다."*
  > *"소프트웨어를 설계하는 방법에는 두 가지가 있다. 하나는 너무 단순해서 결함이 전혀 없는 것처럼 보이게 하는 방법이고, 다른 하나는 너무 복잡해서 결함이 전혀 드러나지 않는 것처럼 보이게 하는 방법이다. 첫 번째 방법이 훨씬 더 어렵다."*

이러한 논의에서 도출되는 중요한 결론은 다음과 같다:

### **단순함은 어렵다.**

그러나, 이 논문의 목적은 **희망을 주는 것**이다.

우리는 논문 후반부에서 복잡성을 줄이기 위한 실질적인 방법을 제시하고, 이를 관계형 모델(relational model)과 결합하여 보다 효과적인 해결책을 모색할 것이다.

마지막으로, 우리가 다루는 복잡성은 이론적인 **계산 복잡도(complexity theory)**와는 전혀 다르다. 몇 줄의 간단한 프로그램도 **이해하기 쉬운 복잡성**을 가질 수 있지만, 이론적으로는 **가장 높은 계산 복잡도**를 가질 수도 있다.

이 논문에서는 **시스템을 이해하기 어렵게 만드는 복잡성**을 중점적으로 다룰 것이다.

다음으로, 우리가 시스템을 이해하는 방법과 복잡성을 초래하는 주요 원인들을 살펴보겠다.

---

## 3. 시스템을 이해하는 접근 방식

소프트웨어 시스템을 효과적으로 이해하기 위해 일반적으로 사용되는 두 가지 주요 접근 방식이 있다.

### 3.1 테스트(Testing)

테스트는 시스템을 "블랙 박스(Black Box)"로 간주하고, 특정 입력에 대한 시스템의 동작을 관찰하는 방식이다. 이를 통해 시스템이 예상대로 동작하는지를 검증할 수 있다.

- **시스템 테스트**: 전체 시스템을 대상으로 수행되며, 사람이 직접 수행하는 경우가 많다.
- **단위 테스트**: 개별 구성 요소를 대상으로 하며, 주로 자동화된 방식으로 수행된다.

그러나 테스트에는 한계가 존재한다. 특정 입력에서 올바른 결과를 얻었다고 해서, 다른 입력에서도 항상 올바르게 동작한다고 보장할 수 없다. 따라서 테스트는 시스템이 올바르게 동작함을 증명하기보다는 **버그의 존재를 탐지하는 역할**에 가깝다.

> *"테스트는 버그의 존재를 증명할 수 있지만, 버그가 없음을 증명할 수는 없다."* — 다익스트라(Dijkstra)

### 3.2 비형식적 추론(Informal Reasoning)

비형식적 추론은 시스템 내부를 분석하여 동작을 이해하는 방식이다. 이는 개발자들이 코드의 흐름을 직접 추론하고 논리적으로 검증하는 과정에서 필연적으로 수행된다.

- 시스템의 논리적 구조를 분석하고 예측할 수 있음.
- 올바른 설계를 통해 오류 발생을 줄일 수 있음.
- 테스트보다 근본적인 해결책을 제공할 수 있음.

비형식적 추론이 중요한 이유는 **오류를 미리 방지할 수 있기 때문**이다. 오류를 미리 방지하는 것이 오류를 찾아 수정하는 것보다 훨씬 효과적이며 비용도 적게 든다.

> *"정말 신뢰할 수 있는 소프트웨어를 원한다면, 처음부터 대부분의 버그를 방지할 수 있는 방법을 찾아야 한다."* — 다익스트라(Dijkstra)

### 3.3 단순성(Simplicity)의 중요성

테스트와 비형식적 추론 모두 한계를 가지므로, **소프트웨어의 단순성을 유지하는 것이 가장 중요한 요소**가 된다.

- 단순한 시스템은 테스트가 용이하며, 유지보수도 쉬움.
- 복잡성이 줄어들수록, 비형식적 추론을 통한 오류 방지가 쉬워짐.
- 테스트보다 **단순한 설계를 우선적으로 고려하는 것이 더 효과적**일 수 있음.

따라서, 시스템을 설계할 때 **가능한 한 단순하게 유지하는 것이 장기적으로 유지보수성과 신뢰성을 높이는 최선의 방법**이다.

---

## 4. 복잡성을 초래하는 요인

### 4.1 상태(State)로 인한 복잡성

소프트웨어 시스템에서 **상태(State)**는 복잡성을 증가시키는 가장 큰 요인 중 하나이다. 누구나 고객 지원 센터에서 "다시 시도해 보세요", "프로그램을 다시 시작하세요", "컴퓨터를 재부팅하세요"와 같은 조언을 들은 적이 있을 것이다. 이러한 조언이 효과적인 이유는 많은 시스템이 상태 관리에서 오류를 포함하고 있기 때문이다.

브룩스는 [Bro86]에서 다음과 같이 말했다.

> "복잡성으로 인해 프로그램의 모든 가능한 상태를 열거하고 이해하는 것이 어렵고, 이로 인해 신뢰성이 떨어진다."

이는 시스템이 수많은 내부 상태를 가질 수 있으며, 상태가 많아질수록 프로그램을 이해하고 테스트하는 것이 더욱 어려워진다는 점을 의미한다.

### 4.1.1 테스트에 미치는 영향

상태는 테스트 과정에서 심각한 문제를 야기한다. 브룩스가 언급한 바와 같이, 상태는 시스템 수준 테스트부터 단위 테스트까지 모든 테스트 과정에 영향을 미친다.

- 시스템이 특정 상태에서 테스트를 통과했다고 해서, 다른 상태에서도 동일하게 동작할 것이라는 보장이 없다.
- 테스트를 수행할 때 시스템을 "초기 상태"로 설정하지만, 실제 운영 환경에서는 다양한 상태 변화가 발생할 수 있다.
- 일부 버그는 특정 상태에서만 발생하며, 테스트 과정에서 이를 찾아내기 어렵다.

결국, 상태가 있는 시스템을 테스트하는 것은 본질적으로 불완전하며, 예측 불가능성을 높인다.

> *"테스트는 버그의 존재를 증명할 수 있지만, 버그가 없음을 증명할 수는 없다."* — 다익스트라(Dijkstra)

### 4.1.2 비형식적 추론에 미치는 영향

상태는 개발자가 시스템의 동작을 추론하는 과정에서도 장애물이 된다.

- 상태가 많아질수록, 시스템이 특정 입력에서 어떤 결과를 낼지 예측하기 어려워진다.
- 개발자는 보통 "이 변수가 이 상태라면 A가 발생하고, 그렇지 않다면 B가 발생한다"는 식으로 논리적으로 추론하지만, 상태가 많아질수록 이러한 추론이 어려워진다.
- 상태를 포함한 함수나 모듈이 많아지면, 의존성이 증가하여 예측 가능성이 더욱 낮아진다.

특히, 상태가 있는 함수와 없는 함수가 섞여 있을 경우, 상태가 없는 함수도 간접적으로 상태에 영향을 받게 되는 **오염(Contamination) 문제**가 발생한다. 이는 시스템의 예측 가능성을 낮추고 유지보수를 어렵게 만든다.

> *"낙타의 코가 천막 안으로 들어오면, 결국 몸 전체가 들어오게 된다."* — 상태의 문제를 설명하는 격언

### 4.2 제어(Control)로 인한 복잡성

제어란 연산이 실행되는 순서를 의미하며, 불필요한 제어 흐름 강제는 복잡성을 증가시킨다.

- 대부분의 프로그래밍 언어는 **명령문(statement)의 순서**를 기반으로 실행 흐름을 결정한다.
- 그러나, 많은 경우 개발자는 연산의 순서가 아니라 값과 관계만을 정의하고 싶어 한다.

예를 들어, 다음과 같은 코드에서 실행 순서는 중요하지 않다.

```pseudo
 a := b + 3
 c := d + 2
 e := f * 4
```

그러나 명령형 언어에서는 이러한 순서를 강제하며, 이는 불필요한 복잡성을 초래한다.

### 4.2.1 동시성(Concurrency) 문제

동시성은 병렬 실행을 다루는 과정에서 발생하는 복잡성을 의미한다.

- 동시성이 있는 시스템에서는 같은 입력을 주더라도 실행 결과가 다를 수 있다.
- 테스트를 동일한 상태에서 수행하더라도, 동시 실행의 영향으로 인해 예측이 어렵다.
- 실행 순서가 명확하지 않으면, 디버깅과 유지보수가 극도로 어려워질 수 있다.

결국, **제어와 상태는 소프트웨어 복잡성을 증가시키는 주요 원인**이며, 가능한 한 이를 최소화하는 방향으로 설계하는 것이 바람직하다.

### 4.3 코드 양(Code Volume)으로 인한 복잡성

코드 양 자체도 복잡성을 증가시키는 주요 요인 중 하나이다.

- 많은 코드가 상태를 관리하거나 제어 흐름을 지정하는 데 사용되므로, 상태와 제어 복잡성이 증가할수록 코드 양도 늘어나게 된다.
- 코드의 양이 많아질수록 유지보수와 가독성이 떨어지고, 오류 가능성이 높아진다.
- 브룩스는 "소프트웨어 개발의 많은 문제는 코드 크기 증가와 비선형적으로 증가하는 복잡성에서 비롯된다"고 지적했다.

> *"프로그램의 길이가 증가할수록, 이를 이해하고 유지보수하는 데 필요한 지적 노력이 기하급수적으로 증가할 가능성이 있다."* — 다익스트라(Dijkstra)

따라서, **코드 양을 최소화하고 단순한 구조를 유지하는 것이 매우 중요하다**.

### 4.4 기타 복잡성 요인

그 외에도 소프트웨어 복잡성을 유발하는 여러 요인이 존재한다.

- **중복 코드(Duplicated Code)**: 기존 기능을 이해하기 어렵거나 코드가 과도하게 복잡할 경우, 동일한 기능이 여러 번 구현되는 문제가 발생한다.
- **사용되지 않는 코드(Dead Code)**: 제거되지 않은 불필요한 코드가 시스템을 불필요하게 복잡하게 만든다.
- **불필요한 추상화(Unnecessary Abstraction)**: 필요 이상으로 추상화를 적용할 경우 코드 이해도가 낮아지고 유지보수가 어려워진다.
- **잘못된 모듈화(Poor Modularity)**: 기능이 적절하게 분리되지 않으면 코드의 응집성이 떨어지고 관리가 어려워진다.
- **부실한 문서화(Poor Documentation)**: 코드의 의도를 파악하기 어려워지고, 시스템의 유지보수가 어렵게 된다.

### 4.4.1 복잡성 증가의 주요 원칙

복잡성 증가를 설명하는 몇 가지 원칙이 있다.

- **복잡성은 복잡성을 낳는다(Complexity Breeds Complexity)**: 코드가 복잡하면 이해하기 어려워지고, 개발자는 동일한 기능을 중복해서 구현하는 경향이 생긴다.
- **단순함은 어렵다(Simplicity is Hard)**: 단순한 설계를 유지하려면 추가적인 노력과 시간이 필요하다. 초기 솔루션이 반드시 가장 단순한 것은 아니다.
- **과도한 기능은 위험하다(Power Corrupts)**: 언어가 강력할수록 실수를 저지를 가능성이 높아지며, 시스템을 이해하기 어려워질 수 있다.

이러한 문제들은 대부분 **상태, 제어, 코드 양을 효과적으로 관리함으로써 완화될 수 있다**.

---

## 5. 복잡성 관리에 대한 고전적인 접근 방식

### 5.1 객체 지향 프로그래밍(Object-Orientation)

객체 지향 프로그래밍(OOP)은 명령형 접근 방식의 확장으로, 상태 기반(von-Neumann) 계산을 쉽게 처리하기 위해 발전해왔다. 객체는 상태와 상태를 조작하는 메서드로 구성되며, 이는 캡슐화(encapsulation)를 통해 관리된다.

#### 5.1.1 상태(State)

- OOP에서는 객체가 상태를 가지며, 해당 상태를 조작하는 메서드를 통해 관리됨.
- 캡슐화를 통해 무분별한 상태 변경을 방지하고 무결성을 유지하지만, 다중 접근 지점이 존재할 경우 동일한 무결성 규칙을 여러 곳에서 적용해야 하는 문제가 발생.
- 다중 객체에 걸친 무결성 검증이 어렵고, 개별 객체 단위의 상태 관리에 초점이 맞춰져 있음.
- 객체 식별(Object Identity)은 상태와 밀접하게 연관되며, 변경 가능한 객체를 구별하는 데 유용하지만, 상태가 필요 없는 경우(Value Object 등)에는 불필요한 복잡성을 추가함.

#### 5.1.2 제어(Control)

- OOP는 기본적으로 명령형 프로그래밍과 동일한 순차적 제어 흐름을 따름.
- 동시성을 다룰 때 공유 상태 기반 모델(shared-state concurrency)을 사용하며, 이는 전통적인 동시성 문제(데드락, 경쟁 상태 등)를 초래할 수 있음.
- 액터 모델(actor model)과 같은 대안이 존재하지만, 실무에서 널리 사용되지 않음.

#### 5.1.3 요약

- OOP는 상태 기반 프로그래밍의 연장선으로, 상태와 제어 흐름 복잡성에서 자유롭지 않음.
- 객체 간 관계 및 상태 관리에서 발생하는 복잡성을 줄이기 위해 추가적인 설계 패턴과 보완 기법이 필요함.

---

### 5.2 함수형 프로그래밍(Functional Programming)

함수형 프로그래밍(FP)은 상태를 제거하고 수학적 함수 개념을 기반으로 한 프로그래밍 패러다임이다. 함수형 언어는 주로 람다 계산법(lambda calculus)을 기반으로 하며, 순수 함수(pure function)와 참조 투명성(referential transparency)을 유지한다.

#### 5.2.1 상태(State)

- 순수 함수형 프로그래밍에서는 상태와 부작용(side effects)을 배제함.
- 참조 투명성을 유지하여 같은 입력에 대해 항상 같은 출력을 반환함.
- 상태를 유지할 필요가 있는 경우, 추가적인 매개변수를 활용하여 상태를 전달하는 방식(Immutable State Passing) 사용.

#### 5.2.2 제어(Control)

- 명시적인 제어 흐름보다는 `map`, `fold`와 같은 고차 함수(higher-order function)를 활용하여 추상적인 제어 구조를 유지함.
- 동시성 측면에서 상태를 사용하지 않기 때문에 부작용 없는 병렬 처리가 용이함.

#### 5.2.3 상태와 모듈화(Modularity)

- 상태를 유지하지 않기 때문에 모듈 간의 의존성이 낮아짐.
- 변경이 필요한 경우 상태를 명시적으로 함수 인자로 전달해야 하므로, 변경 영향이 코드 전체에 드러나는 경향이 있음.

#### 5.2.4 요약

- 함수형 프로그래밍은 상태 기반 복잡성을 제거하는 데 효과적이며, 테스트 및 유지보수성을 향상시킴.
- 그러나, 상태 전달 방식이 코드 가독성을 저해할 가능성이 있으며, 실무 적용에서 어려움을 겪을 수 있음.

---

### 5.3 논리형 프로그래밍(Logic Programming)

논리형 프로그래밍은 "무엇을 해야 하는가"를 기술하는 선언형 접근 방식으로, 명령형 프로그래밍과 대비된다. 프로그래머는 문제를 기술하는 논리적 공리를 제공하며, 시스템이 해당 공리를 기반으로 해결 방법을 찾는다.

#### 5.3.1 상태(State)

- 순수 논리 프로그래밍은 변경 가능한 상태를 사용하지 않음.
- 일부 논리형 언어(Prolog 등)는 상태를 추가할 수 있는 기능을 제공하지만, 참조 투명성을 유지하기 어려워짐.

#### 5.3.2 제어(Control)

- 논리형 언어(예: Prolog)는 암묵적인 목표 탐색(ordering of goal processing) 방식을 사용하며, 이는 때때로 실행 순서를 예측하기 어렵게 만듦.
- 일부 논리형 언어는 명시적인 제어 구조를 제공하지만, 논리적 순수성이 손상될 수 있음.

#### 5.3.3 요약

- 논리형 프로그래밍은 상태를 제거하고 논리적 추론을 통해 복잡성을 줄일 수 있는 가능성을 제시함.
- 그러나, 실무에서 널리 사용되지 않으며, 실행 모델의 예측 가능성이 떨어지는 경우가 많음.

---

## 6. 필수 복잡성과 우발적 복잡성 (Essential vs. Accidental Complexity)

소프트웨어 개발에서 **복잡성은 반드시 해결해야 하는 핵심적인 문제**이다. 그러나 **모든 복잡성이 본질적인 것은 아니다.**

### 6.1 필수 복잡성(Essential Complexity)과 우발적 복잡성(Accidental Complexity)의 차이

- **필수 복잡성**: 시스템이 해결해야 하는 문제 자체에서 비롯되는 복잡성으로, **사용자가 반드시 이해해야 하는 요소들**이다.
- **우발적 복잡성**: 문제 해결을 위해 선택된 기술, 도구, 개발 방식에서 발생하는 불필요한 복잡성으로, **개발자가 관리해야 하는 요소들**이다.

### 6.2 필수 복잡성의 한계와 우발적 복잡성의 제거

**중요한 점은, 개발팀이 특정 복잡성을 반드시 다뤄야 하는지 여부**이다. 만약 **해당 복잡성을 신경 쓰지 않고도 올바른 시스템을 만들 수 있다면, 이는 필수 복잡성이 아니다.**

- 현실적으로 **모든 우발적 복잡성을 제거하는 것은 불가능**하지만, **소프트웨어 엔지니어링의 목표는 이를 최소화하는 데 있다.**
- 필수 복잡성은 사용자가 직접 고려해야 하는 문제와 연관된다. 따라서 **이론적으로는 사용자의 문제를 직접 표현할 수 있는 언어와 인프라가 존재해야 한다.**

### 6.3 기존 주장에 대한 반박

- **Brooks [Bro86]와 Booch [Boo91]는 소프트웨어 복잡성이 본질적(essential)이며 피할 수 없다고 주장**했다.
- 그러나, **소프트웨어 자체가 반드시 복잡해야 하는 것은 아니다.**
- **우리는 현대 소프트웨어에서 발견되는 복잡성 중 상당 부분이 문제 자체에서 비롯된 것이 아니라, 잘못된 설계와 기술 선택에서 발생한 우발적 복잡성이라고 본다.**

### 6.4 결론

우발적 복잡성을 줄이기 위해 **개발자는 다음을 고려해야 한다.**

1. **불필요한 개념 제거**: 사용자에게 직접 노출되지 않는 기술적 개념(예: 스레드 풀, 루프 카운터 등)은 본질적이지 않다.
2. **간결한 설계 채택**: 해결하려는 문제를 직접 표현할 수 있는 도구와 패러다임을 선택해야 한다.
3. **복잡성의 원인 분석**: 현재 사용 중인 기술이 문제 해결에 필수적인지, 아니면 단순히 기존 방식을 따르고 있는지 검토해야 한다.

> **우리는 우발적 복잡성을 줄이고 필수 복잡성을 효과적으로 관리하는 것이 소프트웨어 엔지니어링의 핵심 목표라고 본다.**

---

## 7. 권장하는 일반적인 접근 방식 (Recommended General Approach)

우리가 제안하는 주요 권장 사항은 가능한 한 **우연적 복잡성(accidental complexity)을 피하는 것**을 중심으로 이루어진다.  
이를 위해, 어떤 복잡성이 **우연적인 것인지** 그리고 어떤 복잡성이 **본질적인 것인지**를 명확하게 구분해야 한다.

이를 판단하는 방법은 다음과 같다.
- **이상적인 세계(ideal world)에서도 피할 수 없는 복잡성**을 본질적인 복잡성(essential complexity)으로 간주한다.
- 반면, **이상적인 세계에서는 존재하지 않을 복잡성**을 우연적인 복잡성(accidental complexity)으로 분류한다.

이제, 이러한 이상적인 세계가 얼마나 현실적인지 검토한 후, 최종적인 권장 사항을 제시할 것이다.

---

### 7.1 이상적인 세계 (Ideal World)

이상적인 세계에서는 다음과 같은 가정이 성립한다.
1. **성능(performance)을 고려할 필요가 없다.**
2. **언어(language)와 인프라(infrastructure)는 우리가 원하는 모든 일반적인 지원을 제공한다.**

이러한 배경에서, **우리는 상태(state)와 제어(control)에 대해 검토할 것이다.**
- 이상적인 세계에서 **상태를 제거할 수 있다면**, 그것은 **우연적 상태(accidental state)**이다.
- 마찬가지로, **제어를 제거할 수 있다면**, 그것은 **우연적 제어(accidental control)**이다.

---

### 7.1.1 이상적인 세계에서의 상태 (State in the Ideal World)

이상적인 세계에서 우리가 목표로 하는 것은 **상태(state)를 제거하는 것**이다.  
즉, 가능한 많은 상태가 **우연적인 상태(accidental state)**로 판명되기를 기대한다.

먼저, **사용자의 비공식적인 요구 사항(informal requirements)**에서 출발해보자.
- 사용자의 요구 사항에는 여러 종류의 데이터가 포함될 것이다.
- 일부 데이터는 **상태(state)로 이어질 가능성이 있다.**
- 이제, 이러한 데이터를 분류해보자.

모든 데이터는 다음 중 하나에 해당한다.
1. **입력 데이터(Input Data)** → 시스템에 직접 제공되는 데이터
2. **유도된 데이터(Derived Data)** → 기존 데이터에서 유도된 데이터

또한, **유도된 데이터**는 다음 두 가지 중 하나에 해당한다.
1. **불변(Immutable)** → 단순히 화면 표시 등의 용도로 사용
2. **변경 가능(Mutable)** → 사용자가 명시적으로 해당 데이터를 수정할 수 있음

이제, 이러한 데이터 유형을 분석하여 **본질적인 상태(essential state)와 우연적인 상태(accidental state)를 구분할 수 있다.**

---

#### 입력 데이터 (Input Data)

입력 데이터는 **사용자의 요구 사항에서 직접 정의된 데이터**이므로 본질적인 요소이다.  
이 데이터는 다음 두 가지 경우로 나뉜다.

1. **시스템이 미래에 이 데이터를 참조해야 하는 경우**
    - 이 경우, **데이터를 저장해야 하므로 본질적인 상태(essential state)**에 해당한다.

2. **시스템이 미래에 이 데이터를 참조할 필요가 없는 경우**
    - 예를 들어, 입력이 단순히 **일회성 부작용(side-effect)을 유발하는 경우**,
    - 이 데이터는 유지될 필요가 없으며, 상태로 저장할 필요가 없다.

---

#### 본질적인 유도 데이터 - 불변 (Essential Derived Data — Immutable)

이러한 데이터는 **언제든지 입력 데이터를 기반으로 다시 계산할 수 있다.**  
따라서, **저장할 필요 없이 필요할 때마다 다시 유도할 수 있으며, 이는 우연적인 상태(accidental state)에 해당한다.**

---

#### 본질적인 유도 데이터 - 변경 가능 (Essential Derived Data — Mutable)

이 경우도 마찬가지로, **데이터를 필요할 때 다시 유도할 수 있다면, 이를 저장할 필요가 없다.**  
즉, 이상적인 세계에서는 **이러한 데이터도 우연적 상태(accidental state)로 간주될 수 있다.**

그러나, **유도된 데이터가 지속적으로 변경되어야 한다면**, 이를 저장해야 한다.  
이러한 경우, **해당 데이터는 입력 데이터와 마찬가지로 본질적인 상태(essential state)가 될 수 있다.**

하지만, 유도된 데이터의 변형이 **입력 데이터의 변형과 동일한 방식으로 처리될 수 있다면**,
- 즉, 입력 데이터의 구조적 변형이 단순히 다시 적용될 수 있다면,
- 해당 데이터는 **굳이 상태로 유지할 필요가 없으며, 이를 우연적인 상태로 간주할 수 있다.**

---

#### 우연적인 유도 데이터 (Accidental Derived Data)

사용자의 요구 사항에서 정의되지 않은 상태는 **우연적 상태(accidental state)**이다.

다음의 명령형(Imperative) 스타일의 가상 코드(pseudo-code)를 살펴보자.

```java
procedure int doCalculation(int y)
    // ‘subsidaryCalcCache’는 코드의 다른 곳에서 선언 및 초기화됨
    if (subsidaryCalcCache.contains(y) == false) {
        subsidaryCalcCache.y := slowSubsidaryCalculation(y)
    }
    return 3 * (4 + subsidaryCalcCache.y)
```

위 코드에서 `subsidaryCalcCache`라는 캐시(Cache)를 유지하는 것은  
이상적인 세계에서는 **불필요한 상태(accidental state)**일 가능성이 크다.

이 캐시를 제거하고, 상태를 제거한 버전의 코드를 작성하면 다음과 같다.

```java
procedure int doCalculation(int y)
    return 3 * (4 + slowSubsidaryCalculation(y))
```

이제, 캐시가 제거되었으며,  
이전 코드와 완전히 동일한 결과를 얻을 수 있다.

이는 **사용자의 요구 사항에서 명확하게 정의되지 않은 상태는  
이상적인 세계에서 완전히 제거될 수 있음을 보여준다.**

---

### 상태 분류 요약 (Summary of State in the Ideal World)

이상적인 세계에서 상태를 제거하는 접근 방식은 **함수형 프로그래밍의 원칙을 따른다.**
- 즉, **변경 가능한 상태를 제거하고, 필요할 때마다 데이터를 재계산하는 방식을 따른다.**

하지만, 다음 두 가지를 기억해야 한다.
1. **이상적인 세계에서도 일부 상태는 필수적으로 남아야 한다.**
    - (즉, 입력 데이터와 같은 본질적인 상태는 유지되어야 한다.)

2. **순수 함수형 프로그래밍(pure functional programming)에서도  
   본질적인 상태를 시뮬레이션할 수 있다.**
    - (예를 들어, 입력 데이터를 계속 전달하는 방식으로 상태를 유지할 수도 있다.)
    - 그러나, 이상적인 세계에서는 **불필요한 상태 시뮬레이션도 제거해야 한다.**

위 개념을 표(Table)로 정리하면 다음과 같다.

| 데이터 본질성 | 데이터 유형 | 데이터 변경 가능성 | 분류 |
|--------------|------------|----------------|------------|
| 본질적인 데이터 | 입력 데이터 | - | 본질적 상태 (Essential State) |
| 본질적인 데이터 | 유도 데이터 | 불변 | 우연적 상태 (Accidental State) |
| 본질적인 데이터 | 유도 데이터 | 변경 가능 | 우연적 상태 (Accidental State) |
| 우연적인 데이터 | 유도 데이터 | - | 우연적 상태 (Accidental State) |

이 표에서 **우연적 상태(Accidental State)로 분류된 데이터는  
이상적인 세계에서 모두 제거될 수 있다.**

이 결론은 우리가 오늘날의 소프트웨어 시스템에서 **불필요한 상태가 엄청나게 많다는 사실을 의미한다.**
- 대부분의 캐시(cache), 중간 저장소(intermediate stores), 계산 결과 저장값들이
    - 이상적인 세계에서는 **전혀 필요하지 않다.**
- 이는 소프트웨어의 복잡성을 줄이기 위해, **불필요한 상태를 가능한 한 제거해야 한다는 점을 강조한다.**

### 7.1.2 이상적인 세계에서의 제어 (Control in the Ideal World)

앞서 우리는 일부 상태(state)가 본질적인 것임을 확인했지만,  
**제어(control)는 일반적으로 완전히 생략될 수 있으며, 따라서 전적으로 우연적인 것(accidental)으로 간주된다.**

제어 흐름은 **일반적으로 사용자의 비공식적인 요구 사항(informal requirements)에 포함되지 않으며,**  
따라서 이를 기반으로 도출된 공식적인 요구 사항(formal requirements)에서도 등장하지 않아야 한다.

그렇다면, 제어를 완전히 생략할 수 있다는 말이 무슨 의미일까?

- **프로그램이 실행되려면 반드시 어떤 순서대로 동작이 이루어져야 한다.**
- 그러나, 이것이 우리가 신경 써야 할 부분일 필요는 없다.
- 예를 들어, 우리가 **프로그램의 실행 순서를 걱정해야 할 이유가 없는 것과 마찬가지로,  
  전기가 어떻게 흐르는지를 걱정할 필요도 없다.**
- **개발자로서 중요한 것은 "시스템의 결과(result)"가  
  어떠한 제어 방식(control mechanism)으로 실행되든 영향을 받지 않아야 한다는 점이다.**

이러한 접근 방식은 **논리형 프로그래밍(logic programming)이 가르쳐주는 교훈과 정확히 일치한다.**  
논리형 프로그래밍은 **제어(control)를 완전히 분리할 수 있음을 보여주기 때문이다.**

또한, **대부분의 경우 비공식적인 요구 사항에서 동시성(concurrency)에 대한 언급이 없다는 점을 고려할 때,  
동시성 역시 일반적으로 우연적인 요소(accidental)로 간주될 수 있다.**

이상적인 세계에서는,
- **모든 유한한(stateless) 연산이 "0초"에 수행된다고 가정할 수 있으며(이를 동기성 가설(synchrony hypothesis)이라고 한다),**
- 따라서 연산이 **순차적으로 실행되든 병렬로 실행되든 사용자의 입장에서는 차이가 없다.**

---

### 7.1.3 요약 (Summary)

이상적인 세계에서 우리는 **상태(state)와 제어(control) 모두에서 상당한 복잡성을 제거할 수 있었다.**  
즉, 우리가 현재 소프트웨어 시스템에서 마주하는 복잡성 중 상당 부분이 **우연적인 복잡성(accidental complexity)**임을 확인할 수 있다.

이는 우리가 실제 대형 시스템의 복잡성을 크게 줄일 수 있을 가능성을 시사한다.

그러나 문제는 **실제 세계에서 우리가 얼마나 이상적인 세계에 가까워질 수 있는가?**이다.

---

## 7.2 이론적 및 실질적 한계 (Theoretical and Practical Limitations)

현실 세계는 물론 이상적이지 않다.  
이번 섹션에서는 7.1에서 가정한 이상적인 세계의 조건들이 실제로 얼마나 유지될 수 있는지를 검토해본다.

앞서 우리는 이상적인 세계의 개념이  
**함수형 프로그래밍(functional programming)과 논리형 프로그래밍(logic programming)의 선언적 프로그래밍(declarative programming) 철학과 유사함을 확인했다.**

그러나 **함수형 프로그래밍과 논리형 프로그래밍 역시 결국 상태(state)와 제어(control)를 다뤄야 했다.**

그 이유는 다음과 같다.
1. **상태(state)는 필수적인 요소로 남을 수밖에 없다.**
    - 대부분의 시스템은 본질적으로 일부 상태를 포함해야 한다.
2. **제어(control)는 기본적으로 우연적인 요소이지만,  
   현실적인 관점에서 제어를 제한하고 조정할 필요가 있다.**
3. **실용적인 문제(예: 성능 문제)로 인해 일부 우연적 상태(accidental state)가 필요할 수도 있다.**

이러한 관찰을 통해, 우리가 마주할 수 있는 한계가 어디에 있는지를 가늠할 수 있다.

---

### 7.2.1 공식 명세 언어 (Formal Specification Languages)

먼저, 이상적인 세계에서의 공식적인 요구 사항(formal requirements)에 대해  
**이론적인 문제 하나와 실질적인 문제 하나를 살펴보겠다.**

이전 섹션에서는,  
**비공식적인 요구 사항에서 직접 도출된 공식적인 요구 사항을 실행할 수 있는 것이 이상적일 것이라고 주장했다.**

즉, **공식적인 요구 사항(formal requirements)은 실행 가능한 명세(executable specification)여야 한다.**  
실제로 함수형 프로그래밍과 논리형 프로그래밍은 **실행 가능한 명세로 활용될 수 있는 방법으로 제안된 바 있다.**

그러나, 이러한 접근 방식에는 두 가지 문제가 있다.

1. **이론적인 문제**
    - 실행 가능한 명세가 되기 위해서는 **표현력(expressiveness)**이 제한될 수 있다.
    - 예를 들어, 어떤 변수 `x`에 대해 다음과 같은 명세를 정의하고 싶다고 하자.

      ```
      ¬∃y | f(y, x)
      ```

    - 이 표현은 실행 가능한 명세로 변환하기 어렵다.
    - 따라서 **일부 요구 사항은 실행 가능성이 아니라, 순수한 논리적 형태로 유지되어야 할 수도 있다.**
    - 그러나, 우리의 경험에 따르면 **이러한 고급 표현이 필요한 경우는 흔하지 않다.**
    - 따라서, **이러한 요구 사항을 자연스러운 형식으로 유지하면서,  
      이를 실행할 수 있도록 보완하는 방식이 적절할 수 있다.**

2. **실질적인 문제(성능 문제)**
    - 이상적인 세계에서는 **공식적인 요구 사항을 직접 실행하는 것이 가능해야 한다.**
    - 그러나, 현실 세계에서는 **효율성(efficiency) 문제가 발생할 수 있다.**
    - 즉, 실행 가능한 명세가 실제로 실행되더라도 **너무 느리거나 비효율적일 수 있다.**
    - 따라서, **이러한 실행 가능한 명세를 현실적으로 적용하기 위해  
      일부 우연적인 요소(accidental complexity)가 필요할 수도 있다.**

---

### 7.2.2 표현의 용이성 (Ease of Expression)

마지막으로, **이론적으로는 이상적인 세계에서 우연적인 상태(accidental state)를 제거할 수 있지만,  
일부 경우에는 오히려 이러한 상태를 유지하는 것이 문제를 더 자연스럽게 모델링하는 데 도움이 될 수 있다.**

예를 들어,
- **어떤 유도 데이터(derived data)가 지속적인 사용자 입력(user input)과  
  자신의 이전 값(previous values) 모두에 의존하는 경우**,
- 이러한 데이터를 계속 재계산하는 대신,
- **일부 우연적인 상태(accidental state)를 유지하는 것이 더 자연스러운 해결책이 될 수 있다.**

이를 게임(Game) 예제로 살펴보자.
- **컴퓨터가 조작하는 적(enemy)의 위치(state)를 결정하는 알고리즘을 생각해보자.**
- 이 위치(state)는
    - 모든 과거의 사용자 입력(all prior user inputs)과
    - 초기 시작 위치(initial starting positions)를 통해  
      **유도할 수 있다.**
- 그러나, 매번 이러한 계산을 수행하는 것보다는
    - **적의 현재 위치(state)를 상태로 저장하는 것이 더 직관적인 접근 방식일 수 있다.**

즉, **일부 경우에는 우연적인 상태를 유지하는 것이  
문제를 보다 자연스럽게 표현하는 방법이 될 수 있다.**

---

### 7.2.3 필수적인 우연적 복잡성 (Required Accidental Complexity)

우리는 앞서, 이상적인 세계에서도  
**일부 현실적인 이유로 인해 우연적인 복잡성이 필요할 수도 있음을 확인했다.**

그 이유는 다음과 같다.

1. **성능(Performance)**
    - 일부 우연적인 상태와 제어는 **효율성을 위해 필요할 수 있다.**
    - (7.2.1에서 살펴본 실행 가능한 명세의 성능 문제)

2. **표현의 용이성(Ease of Expression)**
    - 일부 우연적인 상태는 **문제를 더 직관적으로 표현하는 데 유용할 수 있다.**
    - (7.2.2에서 살펴본 게임 속 적(enemy) 위치 예제)

이러한 두 가지 이유로 인해,  
**현실적인 소프트웨어 시스템에서는 일부 우연적인 복잡성을 다시 도입해야 할 수도 있다.**

그러나, **우리가 우연적인 상태를 다시 추가하는 순간,  
우리는 다시 상태와 제어로 인한 복잡성 문제를 마주하게 된다.**

이것이 바로 **소프트웨어 시스템이 "나쁜 상태(bad state)"에 빠지는 주요 원인 중 하나이며,**  
이를 해결하는 것이 우리가 제안하는 방법의 핵심 목표가 된다.

### 7.3 권장 사항 (Recommendations)

우리는, 비록 **필수적인 우연적 복잡성(required accidental complexity)이 존재하더라도**,  
**이상적인 세계(7.1절)의 단순성을 현실 세계에서도 상당 부분 유지할 수 있다고 믿는다.**

이제 이를 어떻게 실현할 수 있을지 살펴보겠다.

---

### **7.3.1 복잡성을 다루기 위한 기본 원칙**

우리가 복잡성(특히 **상태(state)와 제어(control)**)를 다루는 방식은 다음 두 가지 원칙으로 요약할 수 있다.

- **회피(Avoid)**
- **분리(Separate)**

즉, **절대적으로 필수적인 경우를 제외하고는 상태(state)와 제어(control)를 피해야 한다.**

그러나, **완전히 회피하는 것이 불가능한 경우**가 있을 수 있다.
- 일부 복잡성은 **본질적으로 필수적(essential complexity)**이거나,
- 또는 **비록 본질적이지 않더라도, 현실적인 관점에서 유용한(7.2.3절) 경우**가 존재할 수 있다.

이러한 경우에는 **해당 복잡성을 시스템의 다른 부분과 철저히 분리해야 한다.**  
이것이 **"분리(Separate)"**의 개념이다.

이 원칙은 특별히 혁신적인 것은 아니지만,  
**현재 대부분의 소프트웨어 개발 방식과는 상당히 다르다.**

- 오늘날의 일반적인 소프트웨어 개발 방식에서는  
  이러한 원칙이 **중심적인 설계 원칙으로 고려되지 않는다.**
- 우리는 **이러한 기존의 접근 방식이 소프트웨어의 과도한 복잡성을 초래했다고 믿는다.**

이제 이러한 원칙을 구체적으로 적용하는 방법을 살펴보겠다.

---

### **7.3.1 필수적인 우연적 복잡성 (Required Accidental Complexity)**

7.2.3절에서,  
**우연적 복잡성이 반드시 필요한 경우가 두 가지 존재할 수 있음을 확인했다.**

1. **성능(Performance) 문제**
    - 일부 **우연적 상태(accidental state)와 제어(accidental control)**는  
      성능 최적화를 위해 필요할 수 있다.

2. **표현의 용이성(Ease of Expression)**
    - 일부 **우연적 상태(accidental state)**는  
      특정 로직을 더 자연스럽게 표현하는 방법이 될 수 있다.

이제 각각을 어떻게 다룰지 살펴보겠다.

#### **(1) 성능 문제를 위한 해결책**

우리는, **우연적 상태(accidental state)를 명시적으로 관리하는 것은 피해야 한다.**  
대신, 다음과 같은 접근 방식을 추천한다.

- **우연적 상태를 직접 관리하는 것이 아니라,  
  어떤 상태를 사용할 것인지 선언(declare)만 하고,  
  그 상태를 유지하는 것은 별도의 인프라(infrastructure)가 담당하도록 한다.**

이렇게 하면,
- **논리적으로는 상태가 없는 시스템처럼 보이면서도,**
- **성능 최적화를 위해 필요한 상태는 유지할 수 있다.**

이 접근 방식의 주요 장점은 다음과 같다.
- **시스템 로직(logic)에서는 우연적 상태(accidental state)가 존재한다는 사실 자체를 잊을 수 있다.**
- **상태 일관성(state consistency) 문제가 발생할 위험이 줄어든다.**

---

#### **(2) 표현의 용이성을 위한 해결책**

경우에 따라서는,  
**어떤 특정 로직을 구현할 때, 우연적 상태(accidental state)를 유지하는 것이  
더 자연스러운 경우가 있다.**

그러나, 우리는 **이러한 경우에도 "분리(Separate)"의 원칙을 포기하지 말아야 한다.**

- 대신, **우연적 상태가 실제로 본질적인 상태(essential state)인 것처럼 다루도록 한다.**
- 이를 위해, **외부 컴포넌트(external component)를 이용하여  
  우연적 상태를 마치 사용자가 직접 입력한 것처럼 처리할 수 있다.**
    - (예: 내부적으로 생성된 유도 데이터(derived data)를  
      마치 사용자가 직접 입력한 것처럼 시스템이 착각하게 만든다.)

이 방식은 **우연적 상태의 필요성을 인정하면서도,  
논리적 복잡성을 증가시키지 않는 방법**이 된다.

---

### **7.3.2 분리(Separation)와 컴포넌트 간의 관계**

우리가 추천하는 **"분리(Separate)"** 전략은 다음과 같은 두 가지 핵심 개념을 포함한다.

1. **로직과 복잡성의 분리 (Logic / Complexity Split)**
    - **시스템의 순수한 로직(pure logic)과 모든 형태의 복잡성을 분리한다.**
    - 여기서 "복잡성"에는 **상태(state)와 제어(control)**가 포함된다.

2. **본질적 복잡성과 우연적 복잡성의 분리 (Essential / Accidental Split)**
    - 우리가 유지해야 하는 복잡성 중에서도,  
      **본질적인 복잡성(essential complexity)과 우연적인 복잡성(accidental complexity)을 분리한다.**

이 개념을 표로 정리하면 다음과 같다.

| 복잡성 유형 | 권장 접근 방식 |
|------------|--------------|
| **본질적인 로직 (Essential Logic)** | **분리 (Separate)** |
| **본질적인 복잡성 - 상태 (Essential Complexity - State)** | **분리 (Separate)** |
| **유용한 우연적 복잡성 (Accidental but Useful - State / Control)** | **분리 (Separate)** |
| **불필요한 우연적 복잡성 (Accidental and Useless - State / Control)** | **회피 (Avoid)** |

이 구조를 기반으로,  
소프트웨어 시스템을 **3개의 주요 컴포넌트**로 분리할 것을 권장한다.

---

### **추천하는 아키텍처 (Recommended Architecture)**

#### **1. 본질적인 상태(Essential State)**
- **시스템의 "기본적인 데이터 모델(foundation of the system)"을 정의한다.**
- **이 정의는 독립적(self-contained)이며,  
  다른 어떤 시스템 구성 요소에도 의존하지 않는다.**
- **변경이 필요할 경우, 다른 모든 구성 요소도 변경될 수 있다.**

#### **2. 본질적인 로직(Essential Logic)**
- **시스템의 핵심 비즈니스 로직을 정의한다.**
- **본질적인 상태(Essential State)에 대한 조건을 정의하지만,  
  어떻게 상태가 변경되는지는 신경 쓰지 않는다.**
- **우연적 복잡성(Accidental Complexity)과는 완전히 독립적이어야 한다.**
- **우연적 복잡성(Accidental Complexity)이 변경되더라도,  
  본질적인 로직(Essential Logic)은 영향을 받지 않아야 한다.**

#### **3. 우연적 상태 및 제어(Accidental State and Control)**
- **이 시스템의 가장 덜 중요한 부분이다.**
- **본질적인 상태(Essential State) 및 본질적인 로직(Essential Logic)에 영향을 미치지 않아야 한다.**
- **성능 최적화나 표현의 용이성을 위한 "부가적인 기능"을 포함한다.**

---

### **7.4 요약 (Summary)**

이 글의 첫 번째 부분에서 우리는 **소프트웨어 시스템의 주요 위험 요소가 복잡성(complexity)임을 설명했다.**  
그러나, **이러한 복잡성을 회피(Avoid)하거나 제어(Separate)할 수 있는 방법이 있다는 희망을 제시했다.**

우리가 제안하는 접근 방식의 핵심 차별점은,  
**소프트웨어 시스템을 3개의 독립적인 컴포넌트로 분리하는 것**이다.

이러한 분리를 통해,
- **각각의 컴포넌트에서 불필요한 복잡성을 제거할 수 있으며,**
- **전체 시스템을 더 쉽게 이해할 수 있다.**

소프트웨어 개발에서 **복잡성을 통제하지 않으면,  
이는 점점 확산되며 결국 관리할 수 없는 수준에 이르게 된다.**  
따라서, **초기 설계 단계에서 "회피(Avoid)"와 "분리(Separate)"를 최우선 목표로 설정해야 한다.**

이제, **이 원칙을 기반으로 한 실제 접근 방식을 다음 장에서 살펴볼 것이다.**

---

### **8. 관계형 모델(The Relational Model)**

관계형 모델(Relational Model)은 **그 기원과 관계없이 본질적으로 데이터베이스와 직접적인 관련이 있는 개념이 아니다.**  
오히려, **데이터를 구조화하고, 조작하며, 상태의 무결성과 일관성을 유지하는 우아한 방식**으로,  
어떤 맥락에서도 적용할 수 있는 데이터 및 상태 관리 기법이다.

관계형 모델은 다음 네 가지 핵심 요소로 구성된다.

1. **구조(Structure)** – 모든 데이터를 관계(relations)를 사용하여 표현
2. **조작(Manipulation)** – 파생 데이터를 지정하는 방법
3. **무결성(Integrity)** – 데이터에 대한 변경 불가능한 제약 조건을 명시
4. **데이터 독립성(Data Independence)** – 논리적 데이터와 물리적 저장 방식의 명확한 분리

이제 각각의 요소를 간략히 살펴보겠다. 보다 자세한 내용은 [Dat04]에서 확인할 수 있다.

> **참고:** SQL(모든 버전)은 관계형 모델을 정확히 반영하지 않는다.  
> SQL은 **관계형 모델과는 여러 가지 차이점이 있으며, 이를 동일한 개념으로 간주하는 것은 위험하다** [Cod90, p371, Serious flaws in SQL], [Dat04, p xxiv].

---

## **8.1 구조(Structure)**

### **8.1.1 관계(Relations)**

관계형 모델에서 **데이터를 구조화하는 유일한 방법은 관계(relations)이다.**
- 관계는 **동일한 속성을 가진 레코드들의 집합**으로 볼 수 있다.
- 각 레코드는 **이질적인(heterogeneous) 속성(attribute)들의 모음**으로 이루어진다.

이 정의에서 다음과 같은 중요한 특성이 도출된다.
- **관계는 집합(set)이므로 중복된 데이터가 존재할 수 없다.**
- **관계에는 순서(order)가 없다.**
    - 이는 일반적인 테이블(table)과 차이가 있다.
    - 테이블은 중복된 행과 열을 가질 수 있으며, 시각적으로 행과 열의 순서가 존재한다.

#### **관계의 유형**

1. **기본 관계(Base Relations)** – 데이터베이스에 직접 저장되는 관계
2. **파생 관계(Derived Relations, View)** – 다른 관계(기본 관계 또는 다른 파생 관계)로부터 정의되는 관계

Date는 관계를 **단일(복합적인) 값**으로 간주하며,  
변경 가능한 상태를 "**mutable relation**"이 아니라 **관계 변수(relvar)**로 다룬다.

---

### **8.1.2 관계의 구조적 장점 – 접근 경로 독립성(Access Path Independence)**

관계를 이용한 데이터 구조화는  
**데이터 질의 및 처리에서 특정한 접근 경로(access path)를 미리 강제하지 않는다는 점에서 유리하다.**

#### **접근 경로란?**

예를 들어, 직원과 그들이 일하는 부서에 대한 정보를 저장해야 한다고 하자.

- 기존 데이터 모델에서는 **"특정 직원이 특정 부서와 연결되는 경로"**를 미리 정의해야 했다.
- 즉, 데이터 구조를 설계할 때, **어떤 방식으로 데이터를 탐색할지를 사전에 결정해야 했다.**

이러한 **접근 경로 의존성(access path dependence)** 문제는 기존 데이터 모델(네트워크 모델, 계층 모델)에서 큰 단점이었다.

- **계층 모델(Hierarchical Model)**
    - 부서가 최상위 계층(top level)이 될 수도 있고,
    - 반대로 직원이 부서를 포함(contain)하도록 설계될 수도 있다.
    - 한 번 설계하면, 이후 모든 데이터 접근 방식이 이 구조에 의존하게 된다.

- **네트워크 모델(Network Model)**
    - 여러 개의 접근 경로를 설정할 수 있지만,
    - **모든 가능성을 예측할 수 없기 때문에 여전히 문제점이 존재한다.**

관계형 모델은 **이러한 접근 경로의 개념 자체를 제거하면서**,  
**모든 데이터 접근이 동등하게 가능하도록 설계**되었다.

---

## **8.2 조작(Manipulation)**

Codd는 관계형 모델에서 **데이터 조작을 위한 두 가지 기법**을 도입했다.
- **관계 미적분(Relational Calculus)**
- **관계 대수(Relational Algebra)**

이 두 개념은 **이론적으로 동일한 표현 능력을 갖는다.**  
여기서는 **관계 대수(relational algebra)**를 살펴보겠다.

#### **관계 대수(Relational Algebra)의 주요 연산**

1. **Restrict** – 특정 조건을 만족하는 레코드만 선택하는 단항 연산
2. **Project** – 특정 속성을 제거하여 새로운 관계를 생성하는 단항 연산
3. **Product** – 두 관계의 **데카르트 곱(cartesian product)**을 반환하는 이항 연산
4. **Union** – 두 관계의 모든 레코드를 포함하는 새로운 관계 생성
5. **Intersection** – 두 관계에서 공통된 레코드만 포함하는 관계 생성
6. **Difference** – 첫 번째 관계에는 있지만 두 번째 관계에는 없는 레코드를 반환
7. **Join** – 동일한 속성을 가진 레코드를 결합하여 새로운 관계 생성
8. **Divide** – 특정 조건을 만족하는 레코드를 추출하는 삼항 연산

> **장점**: 관계 대수는 **폐쇄성(closure)**을 갖는다.  
> 모든 연산의 피연산자와 결과가 동일한 형태(관계)로 유지되므로,  
> **연산을 중첩(nested)하여 사용할 수 있다.**

---

## **8.3 무결성(Integrity)**

관계형 모델에서 **무결성(integrity)은 선언적 방식으로 유지된다.**

- 무결성 제약 조건을 정의하고,
- 이를 위반하는 변경이 발생하지 않도록 한다.

무결성 제약은 다음과 같은 방식으로 정의될 수 있다.
- **후보 키(Candidate Key)** 및 **기본 키(Primary Key) 제약**
- **외래 키(Foreign Key) 제약**
- **다중 관계를 포함하는 복잡한 무결성 조건**

일부 DBMS에서는 **트리거(Trigger) 같은 명령형 메커니즘**을 제공하지만,  
이는 **관계형 모델의 핵심 원칙과 어긋나며, 복잡성을 증가시킬 수 있다.**

---

## **8.4 데이터 독립성(Data Independence)**

**데이터 독립성은 논리적 데이터 모델과 물리적 저장 방식을 분리하는 원칙**이다.  
이는 관계형 모델이 도입된 주요 동기 중 하나다.

이 원칙은 **본질적인 복잡성과 우연적인 복잡성을 분리(7.3.2절)**하는 개념과 유사하다.  
이는 관계형 모델을 **함수형 관계형 프로그래밍(Functional Relational Programming)**에서 채택하는 중요한 이유 중 하나이다.

---

## **8.5 확장(Extensions)**

관계 대수는 **유연하지만 계산적으로 제한적**(Turing-complete하지 않음)이다.  
따라서, 실제 응용에서는 다음과 같은 확장이 필요할 수 있다.

- **일반 계산 기능**: 산술 연산, 사용자 정의 함수 추가
- **집계 연산(Aggregate Functions)**: `MAX`, `MIN`, `COUNT`, `SUM` 등
- **그룹화(Grouping) 및 요약(Summarization)**: 집계 연산을 그룹별로 적용
- **속성 이름 변경(Renaming)**: 관계의 속성명을 변경하여 새로운 관계를 생성

> **결론:**  
> 관계형 모델은 **데이터 접근 경로를 강제하지 않고, 논리적 설계를 물리적 저장 방식과 분리하며, 무결성을 유지할 수 있도록 설계된 강력한 개념이다.**

---

### **9. 함수형 관계형 프로그래밍 (Functional Relational Programming, FRP)**

함수형 관계형 프로그래밍(FRP)은 **시스템의 본질적인 구성 요소(로직과 필수 상태)를 함수형 프로그래밍과 관계형 모델을 기반으로 구성하는 방식**에서 이름을 따왔다(그림 2 참조).

현재 FRP는 **순전히 이론적인 시스템 아키텍처**로, 실제 환경에서 검증된 사례는 없다.  
그러나 FRP는 관계형 모델, 함수형 프로그래밍, 논리 프로그래밍과 같은 **이미 널리 검증된 원칙들을 기반으로 설계되었다.**

- **FRP에서는 모든 필수 상태(essential state)가 관계(relations) 형태를 갖는다.**
- **필수 로직(essential logic)은 관계 대수(relational algebra)와 순수(pure) 사용자 정의 함수(user-defined functions)의 조합으로 표현된다.**
- **FRP의 핵심 목표는 복잡성을 제거하는 것**이다.

> **참고:** FRP는 *함수형 반응형 프로그래밍(Functional Reactive Programming, FRP)* [EH97]과 이름이 비슷하지만,  
> **관계형 모델을 다룬다는 점에서 전혀 다른 개념이다.**

---

## **9.1 아키텍처 (Architecture)**

FRP 시스템의 아키텍처는 **각 구성 요소가 어떻게 정의되는지**를 통해 설명할 수 있다.  
또한, 이를 구현하기 위해 필요한 **인프라 구조(infrastructure)**도 살펴본다.

FRP는 다음 네 가지 구성 요소를 **분리(separate)**하여 시스템을 구축할 것을 권장한다.

1. **필수 상태 (Essential State)**
    - 시스템의 **상태(stateful components)를 관계형(relational) 방식으로 정의**

2. **필수 로직 (Essential Logic)**
    - **파생 관계(derived relations)**, **무결성 제약(integrity constraints)**, **순수 함수(pure functions)**를 정의

3. **부수적 상태 및 제어 (Accidental State and Control)**
    - **성능 최적화(performance optimizations)를 선언적으로 지정**

4. **기타 (Other)**
    - **외부 시스템 및 사용자와의 인터페이스 정의**

이 구성 요소들은 전통적인 객체지향 프로그래밍(OOP)과 대비되는 방식으로 설계되었다.
- **OOP는 상태와 동작을 결합**하는 반면,
- **FRP는 이를 명확히 분리**하고자 한다.

---

### **9.1.1 필수 상태 (Essential State - "State")**

이 구성 요소는 **시스템의 필수 상태를 관계형 변수(relvars)로 정의하는 부분**이다.

- **모든 상태는 관계형 데이터로 저장된다.**
- 관계형 모델(8.1.1절)에서 설명한 **기본 관계 변수(Base Relvars)**만을 포함한다.
- **실제 데이터가 아니라, 데이터의 구조(이름과 타입)만 정의한다.**

FRP에서는 **사용자가 직접 입력한 데이터만 필수 상태로 간주**할 것을 강력히 권장한다.

---

### **9.1.2 필수 로직 (Essential Logic - "Behaviour")**

필수 로직은 **관계형 연산(Relational Algebra)과 함수형 연산(Functional Operations)을 조합**하여 구성된다.

- **주요 구성 요소**
    1. **파생 관계(derived relvars) 정의**
    2. **관계 대수 연산 적용** (기본 relvars와 파생 relvars 모두 포함)
    3. **순수 사용자 정의 함수(pure user-defined functions) 사용 가능**
    4. **무결성 제약(integrity constraints) 명시**

> 무결성 제약은 **모든 상태 변경이 항상 이 제약을 만족해야 함을 보장한다.**  
> (예: 외래 키 제약, 다중 relvar 제약, 사용자 정의 함수 기반 제약 등)

#### **정규화(Normalization)와 무결성**

- **정규화(Normalization)는 필수 상태의 표현을 간결하게 만들지만, 무결성을 보장하는 것은 아니다.**
    - **무결성 보장은 무결성 제약을 통해 이루어진다.**
    - **정규화가 필요하더라도 성능을 고려하여 데이터 구조를 변경해서는 안 된다.**
    - 성능 최적화는 **"부수적 상태 및 제어(Accidental State and Control)"**에서 다뤄야 한다.

---

### **9.1.3 부수적 상태 및 제어 (Accidental State and Control - "Performance")**

이 구성 요소는 **성능 향상을 위한 최적화 정보**를 선언적으로 정의하는 부분이다.

- **상태 관련 힌트(State-related Hints)**
    - 특정 **파생 관계(derived relvar)를 저장할지 여부 지정**
    - **물리적 저장 방식(Physical Storage Mechanism) 명시**
    - **인덱스, 커스텀 저장 전략 등 지정 가능**

- **제어 관련 힌트(Control-related Hints)**
    - **병렬 평가(parallel evaluation) 여부 지정**
    - **즉시 계산(eager evaluation) vs. 지연 계산(lazy evaluation) 방식 선택**

---

### **9.1.4 기타 (Other - "Interfacing")**

FRP 시스템은 외부 시스템과의 **데이터 입출력 인터페이스를 명확히 정의**해야 한다.

#### **입력(Feeder) - 외부 데이터를 FRP 시스템으로 전달**

- **관계형 할당(Relational Assignment) 방식 사용**
    - 입력 데이터를 특정 **relvar에 할당**
    - 예제:
      ```sql
      relvar := newRelationValue
      ```

- **무결성 제약을 만족하지 않는 입력은 거부됨**
    - 필수 상태의 변경은 반드시 무결성 제약을 준수해야 한다.

#### **출력(Observer) - FRP 시스템에서 외부로 데이터 제공**

- **특정 relvar의 변경을 감지하고 출력 생성**
- **라이브 쿼리(live query) 및 트리거(trigger) 역할 수행**

> **출력은 무결성을 해치는 방식으로 필수 상태를 직접 변경해서는 안 된다.**
> - 단, 표현상의 편의를 위해 가끔 예외적으로 허용될 수도 있음 (7.2.2절 참조)

---

## **9.1.5 인프라(Infrastructure)**

FRP 시스템을 실행하려면, 이를 지원할 **인프라(infrastructure)가 필요하다.**  
이는 FRP 시스템을 **인터프리터 방식으로 실행하거나, 컴파일해서 실행하는 환경**을 의미한다.

**1. 필수 상태를 위한 인프라**
- 관계형 데이터 저장 및 조회 기능
- **무결성 제약을 검증하며 상태 변경 가능해야 함**

**2. 필수 로직을 위한 인프라**
- 관계 대수 연산을 수행할 수 있어야 함
- 함수형 프로그래밍을 지원하는 환경 제공

**3. 부수적 상태 및 제어를 위한 인프라**
- 파생 관계를 저장할지 여부 설정 가능
- 성능 최적화를 위한 저장 전략을 선언적으로 지정할 수 있어야 함

**4. 입력(Feeder) 및 출력(Observer)을 위한 인프라**
- **입력 데이터를 relvar로 변환하여 저장 가능해야 함**
- **출력 데이터를 실시간으로 감지하여 제공 가능해야 함**

---

### **9.2 이 접근 방식의 이점**

FRP는 7장에서 제안한 **"회피(Avoid)와 분리(Separate)"** 원칙을 따르며, 이를 통해 복잡성을 줄이는 다양한 이점을 얻는다.  
다음은 FRP가 **주요 복잡성 원인**을 어떻게 제거하는지에 대한 분석이다.

---

### **9.2.1 상태(State)에 대한 이점**

FRP의 아키텍처는 **불필요한 부수적 상태(accidental state)를 피하고, 시스템이 "잘못된 상태(bad state)"에 빠지는 것을 방지하도록 설계되었다.**

- **파생 상태(derived state)를 저장하지 않음**
    - 파생 상태는 필수 상태(essential state)로 간주되지 않으며, 필요할 때 계산된다.
    - 일반적으로, **하이브리드 피더/옵저버(hybrid feeder/observer)**는 자신이 관찰한 데이터를 그대로 다시 시스템에 반영하지 않는다.
    - 대신, **외부에서 생성된 입력 데이터만 시스템에 제공된다.**
    - 따라서 **잘못된 로직으로 인해 시스템이 "잘못된 상태"에 빠지는 일이 없다.**

- **시스템 오류가 발생하더라도, 단순히 로직을 수정하면 된다.**
    - 기존 필수 상태를 일일이 찾아 수정할 필요가 없음.
    - **시스템을 다시 시작(restart)하거나 재부팅(reboot)할 필요 없음.**

- **"로직/상태 분리" 및 "부수적/필수 요소 분리"가 명확하다.**
    - 로직을 작성할 때 **부수적 상태(accidental state)에 대해 신경 쓸 필요가 없음.**
    - **필수 상태 또한 "상태"가 아니라 "고정된 데이터"처럼 다룰 수 있음.**

- **순수 함수(pure function)는 상태를 직접 참조하지 않음.**
    - 함수는 **오직 전달받은 인자만을 사용**하여 연산을 수행한다.
    - **참조 투명성(Referential Transparency)이 유지되므로, 테스트와 디버깅이 쉬워짐.**

- **관계형 데이터 모델을 사용하여 데이터 접근 경로(access path) 문제를 제거.**
    - OOP나 XML 같은 접근 방식과 달리 **데이터의 구조적 편향(structural bias)이 없다.**
    - 데이터 접근 경로를 강제하는 기존 방식(예: OOP의 객체 참조)과 차별화된다.

- **무결성 제약(Integrity Constraints) 적용이 용이**
    - 순수 선언적 방식으로 무결성을 유지할 수 있음.
    - **제약이 서로 상호작용하지 않으므로 복잡성이 선형적으로 증가** (OOP 방식과 대조적).
    - 특정 **제약 조건이 충돌하지 않는 경우, 성능 최적화를 자동 수행할 수도 있음.**

---

### **9.2.2 제어(Control)에 대한 이점**

FRP에서는 **본질적인 로직(essential logic)에서 제어 흐름(control flow)을 완전히 배제한다.**

- **제어 흐름이 없는 순수한 수학적 방정식(equations) 형태로 로직이 정의됨.**
- **암묵적 병렬성(Implicit Parallelism)을 지원 가능.**
    - 병렬 실행 여부는 인프라 구현자의 책임이며, 시스템 개발자는 신경 쓸 필요 없음.
- **데이터가 관계형 모델로 일관되게 표현되므로, 분산 시스템 구축이 용이함.**

---

### **9.2.3 코드 양(Code Volume) 감소**

FRP는 두 가지 방식으로 **코드 양을 줄인다.**

1. **불필요한 부수적 복잡성을 피함**
    - "필수적인 요소"만 남기고, "불필요한 복잡성"을 제거함으로써 코드 양 자체가 줄어듦.

2. **분리된 아키텍처로 인해 코드 규모가 커지더라도 유지보수가 쉬워짐**
    - (4.3절에서 언급한 것처럼) 코드 볼륨이 증가해도, 구조적 분리가 이루어져 유지보수성이 향상됨.

---

### **9.2.4 데이터 추상화(Data Abstraction)에 대한 이점**

데이터 추상화는 **복잡성을 증가시키는 원인이 될 수 있음.**

- **데이터 그룹화(grouping)는 본질적으로 주관적인 작업이다.**
    - 하나의 목적에 적합한 데이터 그룹화 방식이, 다른 목적에는 적합하지 않을 수 있음.
    - 결과적으로 **잘못된 추상화(abstraction misuse)가 발생할 가능성이 큼.**

- **대규모 데이터 추상화는 참조 투명성을 저해함.**
    - 너무 많은 불필요한 데이터를 함수 인자로 전달하면,
    - **테스트 및 디버깅이 어려워지고, 논리적 오류 발생 가능성이 증가함.**

#### **FRP의 데이터 추상화 접근 방식**
- **최소한의 데이터 그룹화만 수행** (기본 관계 구조만 정의)
- **필요할 경우, 파생 관계(derived relvars)로 다양한 형태의 데이터 구조 제공 가능**
- **중첩된 관계(Nested Relations)나 복합 데이터 타입(Product Types) 사용을 지양**

---

### **9.2.5 기타 이점 (Other Benefits)**

FRP의 다른 잠재적 이점은 다음과 같다.

- **성능 최적화 가능성**
    - 불필요한 데이터 중복을 방지하고, 무결성 제약을 활용하여 성능 최적화 수행 가능.

- **개발팀 역할 분리 가능**
    - 각각의 팀이 **특정 요소에 집중하여 개발 가능.**
    - 예:
        - **"필수 요소(essential components)" 팀** → 비즈니스 로직 설계
        - **"부수적 요소(accidental components)" 팀** → 성능 최적화 및 데이터 저장 설계
        - **"인터페이싱(interfacing)" 팀** → UI 및 외부 시스템 연동 개발
        - **"인프라(infrastructure)" 팀** → 시스템 실행 환경 구축

---

## **9.3 타입(Types)**

FRP는 **기본적인 데이터 타입 외에도 사용자 정의 타입을 제한적으로 지원한다.**

- **사용자 정의 타입**
    - **불연속 유니온 타입(Disjoint Union Types, Enum) 지원**
    - **복합 데이터 타입(Product Types) 미지원**
        - **복잡한 데이터 구조를 피하기 위해 의도적으로 제외됨**
        - 이는 불필요한 데이터 추상화를 방지하기 위한 설계 철학과 일맥상통

- **타입 추론(Type Inference) 지원 가능**
    - **Machiavelli 시스템** [OB88]과 같은 기존 연구에서 제안된 접근 방식을 적용 가능.

---

## **요약 (Summary)**

- **FRP는 복잡성을 줄이기 위해 "필수 요소"와 "부수적 요소"를 철저히 분리하는 방식**을 따른다.
- **상태(State)는 관계형 모델을 사용하여 표현하며, 불필요한 부수적 상태를 제거한다.**
- **제어(Control)는 선언적인 방식으로 정의되며, 암묵적인 병렬 처리를 지원할 수 있다.**
- **데이터 추상화를 최소화하여 참조 투명성을 유지하고, 유지보수성을 향상시킨다.**
- **성능 최적화를 위해 선언적인 "부수적 상태 및 제어" 설정을 별도로 제공한다.**
- **사용자 정의 타입을 제한적으로 지원하며, 타입 추론을 활용할 수 있다.**

FRP는 여전히 **실험적인 접근 방식**이지만, 이론적으로 **객체지향 프로그래밍보다 단순하고 유지보수성이 뛰어난 구조**를 제공할 가능성이 크다.

---

### **10. FRP 시스템 예제**

이번에는 **부동산 중개(estate agency) 비즈니스**를 지원하는 간단한 **FRP 시스템**을 살펴보겠다.  
이 시스템은 다음 정보를 추적하는 역할을 한다.

- 매매 대상 **부동산(Property)**
- 해당 부동산에 대한 **오퍼(Offer)**
- 오퍼에 대한 **소유자의 결정(Decision)**
- 성공적인 매매를 통해 중개인이 얻는 **수수료(Commission)**

이 예제는 **FRP 시스템의 선언적(Declarative) 특성**을 강조하기 위한 것이다.

---

### **10.1 시스템의 기본 가정**

이 시스템은 다음과 같은 제약을 따른다.

1. **매매만 가능하며, 임대(Rental) 및 전세(Lettings)는 제외.**
2. **한 사람이 한 주택만 소유할 수 있으며, 소유자는 매도하는 주택에 거주해야 함.**
3. **모든 방(Rooms)은 완벽한 직사각형 형태를 가짐.**
4. **오퍼 수락(Acceptance)은 계약 체결을 의미하며, 취소 불가.**

예제에서는 **가상의 FRP 인프라**(관계형 대수 연산과 일부 확장 기능을 포함)를 기반으로 하고 있다.

---

## **10.2 필수 데이터(Essential State) 정의**

FRP 시스템에서 **필수 상태(essential state)**는 시스템에서 유지되는 기본(relvar) 데이터 관계를 의미한다.  
각 관계의 속성(attribute) 타입은 **이탤릭체(italic)**로 표시되어 있다.

```plaintext
def relvar Property :: {address: *address*, price: *price*, photo: *filename*, 
                        agent: *agent*, dateRegistered: *date*}

def relvar Offer :: {address: *address*, offerPrice: *price*, offerDate: *date*, 
                     bidderName: *name*, bidderAddress: *address*}

def relvar Decision :: {address: *address*, offerDate: *date*, bidderName: *name*, 
                        bidderAddress: *address*, decisionDate: *date*, accepted: *bool*}

def relvar Room :: {address: *address*, roomName: *string*, width: *double*, 
                    breadth: *double*, type: *roomType*}

def relvar Floor :: {address: *address*, roomName: *string*, floor: *int*}

def relvar Commission :: {priceBand: *priceBand*, areaCode: *areaCode*, 
                          saleSpeed: *speedBand*, commission: *double*}
```

### **각 테이블 설명**
- **Property (부동산)**: 등록된 부동산과 관련 정보를 저장.
- **Offer (오퍼)**: 각 부동산에 대한 오퍼(구매 제안) 기록을 저장.
- **Decision (결정)**: 소유자의 오퍼 수락/거절 여부를 저장.
- **Room (방 정보)**: 각 부동산의 방 크기, 타입 등을 저장.
- **Floor (층 정보)**: 방별 층 정보를 저장.
- **Commission (중개 수수료 정보)**: 중개인 수수료를 결정하는 기준(가격대, 지역, 판매 속도 등).

---

## **10.3 필수 로직(Essential Logic)**
이 부분은 시스템의 **비즈니스 로직(Business Logic)** 을 정의한다.

### **10.3.1 함수 (Functions)**
이 함수들은 개별 정의 없이 동작만 설명한다.

- **priceBandForPrice(가격 → 가격대 변환)**
    - 특정 가격을 가격대(`priceBand`)로 변환하는 함수.
- **areaCodeForAddress(주소 → 지역 코드 변환)**
    - 특정 주소를 지역 코드(`areaCode`)로 변환하는 함수.
- **datesToSpeedBand(날짜 → 판매 속도 변환)**
    - 등록일과 판매 완료 날짜를 기준으로 `speedBand`를 결정.

---

### **10.3.2 파생 관계(Derived Relations)**
총 **13개 파생 관계(derived relations)** 를 정의하며, 이를 **내부(internal) 관계**와 **외부(external) 관계**로 구분한다.

---

### **내부 관계 (Internal Derived Relations)**
#### **1. RoomInfo (방 크기 정보)**
```plaintext
RoomInfo = extend(Room, (roomSize = width * breadth))
```
- **방(Room)의 면적(roomSize)을 계산하여 추가.**

---

#### **2. Acceptance (오퍼 수락 정보)**
```plaintext
Acceptance = project_away(restrict(Decision | accepted == true), accepted)
```
- **수락된 오퍼만 필터링하여 저장.**

---

#### **3. Rejection (오퍼 거절 정보)**
```plaintext
Rejection = project_away(restrict(Decision | accepted == false), accepted)
```
- **거절된 오퍼만 필터링하여 저장.**

---

#### **4. PropertyInfo (부동산 추가 정보)**
```plaintext
PropertyInfo =
extend(Property,
  (priceBand = priceBandForPrice(price)),
  (areaCode = areaCodeForAddress(address)),
  (numberOfRooms = count(restrict(RoomInfo | address == address))),
  (squareFeet = sum(roomSize, restrict(RoomInfo | address == address))))
```
- **부동산 가격대(priceBand), 지역 코드(areaCode), 방 개수(numberOfRooms), 총 면적(squareFeet) 추가.**

---

#### **5. CurrentOffer (현재 오퍼)**
```plaintext
CurrentOffer =
summarize(Offer,
  project(Offer, address bidderName bidderAddress),
  quota(offerDate, 1))
```
- **가장 최근 오퍼만 남김.**

---

#### **6. RawSales (거래된 부동산)**
```plaintext
RawSales =
project_away(join(Acceptance,
  join(CurrentOffer,
  project(Property, address agent dateRegistered))),
  offerDate bidderName bidderAddress)
```
- **수락된 오퍼 정보를 조합하여 매매된 부동산 기록.**

---

#### **7. SoldProperty (판매 완료된 부동산)**
```plaintext
SoldProperty = project(RawSales, address)
```
- **판매 완료된 부동산의 주소만 저장.**

---

#### **8. UnsoldProperty (판매되지 않은 부동산)**
```plaintext
UnsoldProperty = minus(project(Property, address), SoldProperty)
```
- **등록되었지만 아직 판매되지 않은 부동산 정보.**

---

#### **9. SalesInfo (판매 정보)**
```plaintext
SalesInfo =
project(extend(RawSales,
  (areaCode = areaCodeForAddress(address)),
  (saleSpeed = datesToSpeedBand(dateRegistered, decisionDate)),
  (priceBand = priceBandForPrice(offerPrice))),
  address agent areaCode saleSpeed priceBand)
```
- **부동산의 판매 속도(saleSpeed), 가격대(priceBand) 등 추가.**

---

#### **10. SalesCommissions (중개 수수료)**
```plaintext
SalesCommissions =
project(join(SalesInfo, Commission),
  address agent commission)
```
- **각 중개인에게 할당된 수수료 계산.**

---

### **외부 관계 (External Derived Relations)**
#### **11. OpenOffers (진행 중인 오퍼)**
```plaintext
OpenOffers =
join(CurrentOffer,
  minus(project_away(CurrentOffer, offerPrice),
  project_away(Decision, accepted decisionDate)))
```
- **아직 결정되지 않은 오퍼만 필터링.**

---

#### **12. PropertyForWebSite (웹사이트용 부동산 정보)**
```plaintext
PropertyForWebSite = project( join(UnsoldProperty, PropertyInfo),
  address price photo numberOfRooms squareFeet )
```
- **판매되지 않은 부동산 중 웹사이트에 공개할 속성만 선택.**

---

#### **13. CommissionDue (중개인별 총 수수료)**
```plaintext
CommissionDue =
project(summarize(SalesCommissions,
  project(SalesCommissions, agent),
  totalCommission = sum(commission)),
  agent totalCommission)
```
- **각 중개인(agent)의 총 수수료를 합산하여 계산.**

---

### **10.3.3 무결성 (Integrity)**

무결성 제약(integrity constraints)은 **관계형 대수(relational algebra)** 또는 **관계형 계산(relational calculus)** 표현식으로 정의된다.  
가정한 FRP 인프라는 **일반적인 관계형 대수 확장(8.5절 참조)** 과 **후보 키(candidate key), 외래 키(foreign key)** 를 위한 특별한 구문을 제공한다.  
(이 구문은 실제로는 관계형 대수 또는 관계형 계산 표현식을 단순화한 형태일 뿐이다.)

우선 **기본적인 키(Key) 제약**을 정의하겠다.

```plaintext
candidate key Property = (address)
candidate key Offer = (address, offerDate, bidderName, bidderAddress)
candidate key Decision = (address, offerDate, bidderName, bidderAddress)
candidate key Room = (address, roomName)
candidate key Floor = (address, roomName)
candidate key Commission = (priceBand, areaCode, saleSpeed)

foreign key Offer (address) in Property
foreign key Decision (address, offerDate, bidderName, bidderAddress) in Offer
foreign key Room (address) in Property
foreign key Floor (address) in Property
```

### **도메인 관련 추가 무결성 제약**
도메인(부동산 거래)에 맞게 정의한 추가 무결성 제약은 다음과 같다.

1. **모든 부동산은 적어도 하나 이상의 방(Room)을 가져야 한다.**
```plaintext
count(restrict(PropertyInfo | numberOfRooms < 1)) == 0
```

2. **집주인은 자신의 집에 오퍼를 넣을 수 없다.**
```plaintext
count(restrict(Offer | bidderAddress == address)) == 0
```

3. **매매가 완료된 부동산(Offer가 수락된 Property)에 대해 새로운 오퍼를 제출할 수 없다.**
```plaintext
count(restrict(join(Offer, project(Acceptance, address decisionDate)) 
               | offerDate > decisionDate)) == 0
```

4. **웹사이트에서 광고할 수 있는 PREMIUM 등급 부동산 개수는 최대 50개이다.**
```plaintext
count(restrict(extend(PropertyForWebSite, 
               (priceBand = priceBandForPrice(price))) 
               | priceBand == PREMIUM)) < 50
```

- 이 제약은 `priceBandForPrice` 라는 사용자 정의 함수(user-defined function)를 직접 참조한다.
- 만약 이 함수의 정의가 변경되면서 기존 데이터가 무결성 제약을 위반할 경우, FRP 인프라는 시스템을 실행하지 않거나 강제 수정이 필요하도록 할 것이다.

5. **단일 구매자(bidder)는 같은 부동산에 대해 10번 이상의 오퍼를 제출할 수 없다.**
```plaintext
count(restrict(summarize(Offer, 
               project(Offer, address bidderName bidderAddress), 
               numberOfOffers = count()) 
               | numberOfOffers > 10)) == 0
```

---

### **10.4 부수적 상태 및 제어 (Accidental State and Control)**

FRP 시스템에서 **부수적 상태 및 제어(accidental state and control)** 는 **성능 최적화 힌트** 를 포함하는 선언적인 명세일 뿐이다.

```plaintext
declare store PropertyInfo
```
- `PropertyInfo` 파생 관계를 **캐싱**(caching)하도록 요청한다.  
  (즉, 계속 재계산하는 대신 한 번 계산 후 저장하도록 한다.)

```plaintext
declare store shared Room Floor
```
- `Room` 과 `Floor` 관계를 **공유된 저장소(shared storage)에 비정규화(denormalization)** 하여 저장하도록 요청한다.
    - 즉, 이 두 테이블을 분리하지 않고 하나의 물리적 구조로 통합하여 관리한다.
    - 하지만, 시스템의 논리적인 관점에서는 여전히 `Room` 과 `Floor` 는 독립적인 개념으로 유지된다.

```plaintext
declare store separate Property (photo)
```
- `Property` 테이블의 `photo` 속성을 **다른 속성과 별도로 저장** 하도록 요청한다.
    - (예: 사진 데이터는 크기가 크기 때문에, 나머지 속성과 함께 저장하는 대신 별도의 스토리지에서 관리하는 것이 성능상 유리하다.)

이러한 최적화 힌트들은 **상태(State)와 관련된 최적화** 만 포함되어 있지만, 대규모 시스템에서는 **제어(Control) 관련 최적화** 도 포함될 수 있다.

---

### **10.5 기타 (Other)**

이 시스템에서 **피더(Feeder)와 옵저버(Observer)** 는 상대적으로 단순하다.

- **Feeder** (데이터 입력 처리):
    - 사용자 입력을 받아 `Offer`, `Decision` 등에 반영한다.
- **Observer** (데이터 출력 처리):
    - `OpenOffers`, `PropertyForWebSite`, `CommissionDue` 같은 파생 관계를 관찰하고 UI나 외부 시스템에 제공한다.

이러한 입력/출력은 별도의 커스텀 코딩 없이 **완전히 선언적으로** 정의될 수 있다.  
예를 들어, `CommissionDue` 를 외부 급여 시스템과 연동하는 요구사항이 있다면, 해당 부분만 커스텀 옵저버를 추가하면 된다.

---

## **11. 관련 연구 (Related Work)**

FRP는 다양한 연구에서 영향을 받았다.

1. **[DD00]**
    - FRP는 **일반적인 대규모 애플리케이션** 을 대상으로 하며, 일부 연구와는 다른 접근 방식을 사용한다.
    - 특히 **별도의 함수형 하위 언어** 를 사용하며, **데이터 타입(type)에 대한 접근 방식도 다르다.**
    - 또한 **DBMS의 물리적/논리적 매핑보다 더 넓은 범위의 부수적 요소를 고려한다.**

2. **Backus의 적용 상태 전이 시스템 (Applicative State Transition Systems, [Bac78])**
    - FRP는 Backus의 개념과 유사한 부분이 있다.

3. **McGill 대학의 Aldat 프로젝트 [Mer85]**
    - 관계형 대수의 일반적 응용 연구로, FRP와 비슷한 개념을 포함하고 있다.

---

## **12. 결론 (Conclusions)**

이 논문에서는 **대규모 소프트웨어 시스템에서 가장 큰 문제는 복잡성(Complexity)** 이며, 이를 효과적으로 다루는 방법을 제안했다.

### **핵심 주장**
1. **복잡성은 필연적이지만, 이를 줄이거나 통제할 수 있다.**
2. **소프트웨어 시스템은 3가지 주요 요소로 분리될 수 있다.**
    - **필수 상태 (Essential State)**
    - **필수 로직 (Essential Logic)**
    - **부수적 상태 및 제어 (Accidental State & Control)**
3. **이러한 분리를 기반으로 각 요소를 다른 특화된 언어(specialized language)로 구현하면, 단일 프로그래밍 패러다임을 적용하는 것보다 단순성을 유지할 수 있다.**
4. **관계형 모델, 함수형 프로그래밍, 논리 프로그래밍의 강점을 결합한 FRP는 이러한 접근 방식을 가능하게 한다.**

### **객체지향 프로그래밍(OOP)와의 차이**
- OOP는 본질적으로 **명령형(imperative) 접근 방식** 이며, **필수 상태와 부수적 상태의 구분이 모호** 하다.
- 반면, FRP는 **로직과 상태를 분리하여 복잡성을 줄인다.**

### **마지막 질문**
- **프로그래밍의 '타르 구덩이(tar pit)'에서 빠져나오는 방법은 무엇인가?**
- **'마법의 총알(Silver Bullet)'은 무엇인가?**

FRP가 완벽한 해법이 아닐 수 있지만, **분명한 해법은 "단순성(Simplicity)" 이다.**